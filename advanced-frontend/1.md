## 写 React / Vue 项目时为什么要在循环渲染列表组件中写 `key`，其作用是什么？

在 React 和 Vue 中，列表组件(如数组渲染的列表)是常见的组件类型之一，当列表中的元素发生变化时，React 和 Vue 会进行 `diff` 操作，以判断哪些元素需要重新渲染，这个过程中就需要一个标识来区别不同的元素，这个标识就是 `key`

### React 

在 React 中，每个 `key` 都对应着一个组件实例的 `instance`，当列表元素发生变化时，React 会使用 `key` 来判断哪些元素需要更新，哪些需要删除，哪些需要添加，在更新过程中，React 会尽可能的复用已有的 `instance`，从而避免频繁的创建和销毁组件实例，提高性能

### Vue

在 Vue 中，`key` 有类似的作用

### 不使用 `key`

如果不使用 `key` 来进行列表渲染，在模版内容 **简单** 的情况下，`diff` 的速度会更快，因为这种情况下 Vue 会进行 **就地复用**，而如果带上 `key` 的话，会在增删节点上有所耗时，即不进入后序多次的双端 diff 算法，因为第一次比对就会 match，进而直接 `patch` 新旧节点

但在这种情况下会出现一些副作用，比如可能不会产生过度效果，或者某些节点在绑定数据状态，会出现状态错位


### `key` 的作用

`key` 时给每一个 `vnode` 的唯一标识，Vue 可以依靠 `key`，更快、更准确的拿到 `oldVnode` 中对应的 `vnode` 节点

#### 更快

因为带 `key` 就不是 **就地复用** 了，在 `sameNode` 函数 `a.key === b.key` 的对比可以避免就地复用的情况，所以会更加准确


### 就地复用

就地复用(in-place patching) 是一种优化技术，用于尽可能减少 DOM 操作，提高渲染性能

在 Vue 的虚拟 DOM 中，当一个组件重新渲染时，它的子组件也可能需要重新渲染，如果子组件的结构没有改变，Vue 可以尝试复用子组件的 DOM 节点，而不是完全重新创建

这种复用称为就地复用，Vue 使用 `key` 属性来识别列表中不同的子组件，以便在重新渲染时能够正确的复用它们的 DOM 节点，如果没有 `key` Vue 会默认使用索引作为 `key`