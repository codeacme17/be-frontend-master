## 深入理解浏览器的缓存机制

> Reference: [jianshu](https://www.jianshu.com/p/54cc04190252)

### 缓存位置

从缓存位置上来说可以分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会请求网络

- Service Worker
  Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须是 HTTPS，因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他的内建缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是连续性的

- Memory Cache
  Memory Cache 也就是内存中的缓存，主要包含的是当前页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放（关闭 Tab）
  内存缓存中有一块重要的缓存资源是 `preloader` 相关指令（如 `<link rel='prefetch'>`）下载的资源，需要注意的是，内存缓存在缓存资源时并不关心返回资源的 HTTP 头 `Cache-Control` 时什么值，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 `Content-Type`、`CORS` 等其他特性做校验

- Disk Cache
  Disk Cache 是存储在硬盘中的缓存，读取速度相比内存缓存较慢，但是任何东西都可以存储在磁盘中，比后者胜在容量和实效性上
  在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的，它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接访问等等

  - 浏览器会将哪些文件存入内存，哪些存入硬盘？
    1. 对于大文件来说，基本上会存入硬盘
    2. 当前系统内存使用率高的话，文件会优先存入硬盘

- Push Cache
  推送缓存是 HTTP/2 的特性，当以上三种缓存均未命中时，它才会被使用。它只在会话（Session）中存在，一旦绘画结束就被释放，并且缓存时间也很短暂（在 Chrome 中只有 5 分钟左右）同时它也并非严格执行 HTTP 头中的缓存指令

### 缓存过程分析

- 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识

- 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中

### 强缓存

强缓存是当我们访问 URL 的时候，不会向服务器发送请求，而是直接从缓存中读取资源，但是会返回 `200` 的状态码

- `expires` 是 HTTP1.0 控制页面缓存的字段，与 cookie 中的 `Expires` 属性类似，可能会出现时间不一致问题
- `Cache-Control` 是 HTTP1.1 中控制页面缓存的字段，当 `Cache-Control` 和 `expires` 同时存在时，`Cache-Control` 拥有更高的优先级，取值：
  - `public` 客户端和代理服务器都可以缓存资源
  - `private` 只有客户端可以缓存资源
  - `no-cache` 当在请求头被使用时，表示强制使用协商缓存；当在响应头被返回时，表示缓存服务器不能对资源进行缓存，客户端可以缓存资源，但必须使用协商缓存
  - `no-store` 不允许任何缓存
  - `max-age` 代表缓存在多久后过期，单位为[秒]

### 协商缓存

协商缓存是在强制缓存失效或者 `Cache-Control` 为 `no-cache` 的时候启用的缓存策略，浏览器携带缓存标识向服务器发送请求，有服务器根据标识信息决定是否使用缓存的过程

- `Last-Modified` (响应头)是服务器响应请求时，返回该文件在服务器最后被修改的时间
- `If-Modified-Since` (请求头)是客户端再次发起请求时，携带上次请求返回的 `Last-Modified` 值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，会根据该字段与服务器资源在服务器最后被修改的时间做对比，如果最后修改时间大于该值，则返回新资源 `200`，如果不大于则可继续使用缓存的资源 `304`
- `Etag` (响应头)是服务器响应请求时，返回当前资源文件的唯一标识符，由服务器生成，如果资源更新该值也会发生变化
- `If-None-Match` (请求头)是客户端再次发送请求时，携带上次返回的 `Etag` 值，通过此字段告诉服务器该资源上次请求返回的唯一标识符，服务器会根据该值与该资源在服务器的当前 `Etag` 值做对比

`Etag/If-None-Match` 组合的优先级高于 `Last-Modified/If-Modified-Since` 组合，其中前者是 HTTP1.1 提出的功能，而后者是 HTTP1.0 的功能

- `Etag/If-None-Match` 有更好的精确度，可以更深层的感知资源的变化，比如文件只是编辑过但是没有更改内容，这样也会造成缓存失效
- `Last-Modified/If-Modified-Since` 有更好的性能，因为他只是记录一个时间点，而 `Etag` 需要根据文件具体内容生成哈希值

### 实际场景应用缓存策略

- 频繁变动的资源 - `Cache-Control: no-cache`
  对于频繁变动的资源，首先需要使用 Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小

- 不常变化的资源 - `Cache-Control: max-age=31536000`
  通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000 (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)
