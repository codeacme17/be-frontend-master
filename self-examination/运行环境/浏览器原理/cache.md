## 深入理解浏览器的缓存机制

> Reference: [jianshu](https://www.jianshu.com/p/54cc04190252)

### 缓存位置

从缓存位置上来说可以分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会请求网络

- Service Worker
  Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须是 HTTPS，因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他的内建缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是连续性的

- Memory Cache
  Memory Cache 也就是内存中的缓存，主要包含的是当前页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放（关闭 Tab）
  内存缓存中有一块重要的缓存资源是 `preloader` 相关指令（如 `<link rel='prefetch'>`）下载的资源，需要注意的是，内存缓存在缓存资源时并不关心返回资源的 HTTP 头 `Cache-Control` 时什么值，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 `Content-Type`、`CORS` 等其他特性做校验

- Disk Cache
  Disk Cache 是存储在硬盘中的缓存，读取速度相比内存缓存较慢，但是任何东西都可以存储在磁盘中，比后者胜在容量和实效性上
  在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的，它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接访问等等

  - 浏览器会将哪些文件存入内存，哪些存入硬盘？
    1. 对于大文件来说，基本上会存入硬盘
    2. 当前系统内存使用率高的话，文件会优先存入硬盘

- Push Cache
  推送缓存是 HTTP/2 的特性，当以上三种缓存均未命中时，它才会被使用。它只在会话（Session）中存在，一旦绘画结束就被释放，并且缓存时间也很短暂（在 Chrome 中只有 5 分钟左右）同时它也并非严格执行 HTTP 头中的缓存指令

### 强缓存

强缓存是当我们访问 URL 的时候，不会向服务器发送请求，而是直接从缓存中读取资源，但是会返回 `200` 的状态码

- `Expires`

  HTTP/1.0 规范中使用，标识资源的过期时间。如果请求的时间小于 `Expires` 指定的时间，浏览器就直接使用缓存的资源。但由于 `Expires` 是一个绝对时间，客户端和服务器时间可能不一致，导致缓存控制不精确

- `Cache-Control`

  HTTP/1.1 中控制页面缓存的字段，当 `Cache-Control` 和 `Expires` 同时存在时，`Cache-Control` 拥有更高的优先级，取值：

  - `public` 客户端和代理服务器都可以缓存资源

  - `private` 只有客户端可以缓存资源

  - `no-cache` 当在请求头被使用时，表示强制使用协商缓存；当在响应头被返回时，表示缓存服务器不能对资源进行缓存，客户端可以缓存资源，但必须使用协商缓存

  - `no-store` 不允许任何缓存

  - `max-age` 代表缓存在多久后过期，单位为[秒]

#### 强缓存的一些策略

- 缓存静态资源

  ```http
  Cache-Control: public, max-age=31536000
  ```

- 需要重新验证

  ```http
  Cache-Control: no-cache
  ```

  或

  ```http
  Cache-Control: max-age=0, must-revalidate
  ```

### 协商缓存

协商缓存是在强制缓存失效或者 `Cache-Control` 为 `no-cache` 的时候启用的缓存策略，浏览器携带缓存标识向服务器发送请求，有服务器根据标识信息决定是否使用缓存的过程。协商缓存主要通过以下两对 HTTP 头实现：

- `Last-Modified`(响应头) 和 `If-Modified-Since`(请求头)

  服务器通过 `Last-Modified` 响应头告诉浏览器资源最后的修改时间。浏览器再次请求该资源时，通过 `If-Modified-Since` 请求头将之前的 `Last-Modified` 值发送给服务器。服务器比较这个时间和资源的当前修改时间，如果资源没有变化，则返回 `304` 状态码，浏览器就会使用缓存资源

- `ETag`(响应头) 和 `If-None-Match`(请求头)

  HTTP/1.1 提出的功能，相比于上面的组合优先级更高。`ETag` 是资源的唯一标识符，服务器通过 `ETag` 响应头告诉浏览器。浏览器再次请求资源时，通过 `If-None-Match` 请求头将之前的 `ETag` 值发送给服务器。服务器比较 `ETag`，如果资源没有变化，则返回 `304` 状态码，浏览器继续使用缓存的资源

### 缓存过程分析

1. 浏览器第一次加载资源，服务器返回 `200`，浏览器将资源从服务器上请求并下载下来，并把响应头及该请求的返回时间一并保存

2. 检查强缓存，如果有效则直接使用缓存资源

3. 如果强缓存失效，浏览器发送请求到服务器，携带 `If-Modified-Since` 或 `If-None-Match` 头

4. 服务器根据这些头信息决定资源是否修改

   - 如果资源未修改（协商缓存有效），服务器返回 `304` 状态码，浏览器使用缓存资源

   - 如果资源已修改或协商缓存规则不适用，服务器返回 `200` 状态码和新的资源内容，浏览器更新缓存

### 实际场景应用缓存策略

- 频繁变动的资源 - `Cache-Control: no-cache`
  对于频繁变动的资源，首先需要使用 Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小

- 不常变化的资源 - `Cache-Control: max-age=31536000`
  通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000 (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)
