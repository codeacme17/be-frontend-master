## 常见的排序算法和对应的时间复杂度

### 冒泡排序（Bubble Sort）

通过重复遍历要排序的数列，比较每对相邻元素的值，若发现顺序错误则交换位置，直到没有需要交换的

- 时间复杂度：平均 O(n^2)，最好 O(n)，最坏 O(n^2)

- 空间复杂度：O(1)

### 选择排序（Selection Sort）

遍历数组，每次从未排序的部分找出最小（或最大）的元素，放到已排序的序列的末尾

- 时间复杂度：平均 O(n^2)，最好 O(n^2)，最坏 O(n^2)

- 空间复杂度：O(1)

### 插入排序（Insertion Sort）

通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入

- 时间复杂度：平均 O(n^2)，最好 O(n)，最坏 O(n^2)

- 空间复杂度：O(1)

### 快速排序（Quick Sort）

选择一个元素作为 ”基准“（pivot），分区过程中将小于 ”基准“ 的元素放到左边，将大于的放在右边，然后递归地对分区进行快速排序

- 时间复杂度：平均 O(n log n)，最好 O(n log n)，最坏 O(n^2)

- 空间复杂度：平均 O(log n)，由于递归调用的栈空间

### 归并排序（Merge Sort）

采用分治法（Divide and Conquer），将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，然后使子序列段间有序

- 时间复杂度：平均 O(n log n)，最好 O(n log n)，最坏 O(n log n)

- 空间复杂度：O(n)，需要与原数组相等的存储空间进行合并操作

### 堆排序（Heap Sort）

利用堆这种数据结构所设计的一种排序算法，堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父节点

- 时间复杂度：平均 O(n log n)，最好 O(n log n)，最坏 O(n log n)

- 空间复杂度：O(1)

### 希尔排序（Shell Sort）

是插入排序的一种更高效的改进版本。希尔排序会先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序

- 时间复杂度：取决于间隔序列，最好 O(n log n)，平均和最坏情况较复杂，依赖于增量序列的选择

- 空间复杂度：O(1)
