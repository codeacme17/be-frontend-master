## 理解 Mobx 实现原理，相比于 Redux 的优劣势

Mobx 是一个在 Javascript 应用中用于管理状态的库，其主要目标是使状态管理简单且可扩展。Mobx 通过响应式编程原理来实现状态管理，与 Redux 作为一个更加声明式和函数式的状态管理库有着本质的不同

### Mobx 实现原理

Mobx 的核心原理基于以下几个概念：可观察状态（Observables）、计算值（Computed values）、反应（Reactions）和动作（Actions）。这些概念共同工作，以实现高效的状态管理和 UI 更新

- 可观察状态（Observables）

  Mobx 使得应用状态变成可观察的。当状态改变时，Mobx 能够追踪这些变化，并自动通知那些依赖于这些状态的计算值和反应

- 计算值（Computed Values）

  这些是可以从现有状态或其他计算值衍生出来的值。当依赖的状态改变时，计算值会自动重新计算

- 反应（Reactions）

  当状态改变时，反应自动运行，典型的反应是更新 UI

- 动作（Actions）

  改变状态的函数。在 Mobx 中，推荐通过动作来改变可观察的状态，这有助于管理状态的变化

Mobx 使用响应式编程原理，其中最关键的是其使用依赖追踪来自动确定哪些计算值和反应应当在状态变化时被重新执行。这种机制极大的简化了状态到 UI 的同步过程，开发者只需要关心状态的变化，Mobx 会负责确定何时和如何更新 UI

### Mobx 和单向数据流

虽然 Mobx 使用的是响应式编程模型，它仍然遵循单向数据流的原则，但以不同的方式实现：

- 状态到视图（State -> View）

  当可观察的状态（observables）发生变化时，Mobx 会自动追踪这些变化并通知计算属性（computed values）或反应（reactions），这包括更新依赖这些状态的组件。这个过程遵循单向数据流，因为数据的变化导致了视图的更新

- 视图到状态（View -> State）

  当用户交互导致需要更新状态时（例如，用户输入），这通常通过动作（actions）来实现。在 Mobx 中，动作是改变状态的推荐方式。虽然动作可能会响应于视图层的事件（如点击事件），但状态到视图的更新仍然时自动和单向的

#### 为什么感觉像双向绑定

Mobx 的响应式特性自动处理状态到视图的更新，这使得开发者不需要显示编写用于同步视图和状态的代码，从而给人一种双向数据绑定的感觉。然而，与传统的双向数据绑定（如 Angular JS 的 `$scope` 机制）不同，Mobx 保持了更新逻辑的明确性和可控性，因为所有状态都是可追踪可预测的，遵循单向数据流的原则

### 相比于 Redux 的优劣势

#### 优势

- 简化状态管理：Mobx 自动处理依赖追踪和状态更新，减少了模板代码和样板代码，使得状态管理更加简单直接

- 更好的性能：由于 Mobx 只更新依赖于改变的状态的组件，而不是像 Redux 那样在每个状态更新时都可能需要通过中间件和 reducer 来处理，因此在很多场景下可以提供更好的性能

- 更少的概念负担：相比于 Redux 的严格的单向数据流、Reducer、中间件等概念，Mobx 提供了更少的抽象层次，新手更容易上手

- 更灵活的架构：Mobx 允许有多个存储（store），并且不强制要求单一数据源或不可变数据，给予开发者更多的灵活性

#### 劣势

- 隐式依赖和副作用

  - 隐式依赖：Mobx 的自动依赖跟踪意味着开发者可能不选哟显示定义组件依赖的状态。这种隐式性虽然简化了代码，但有时也可能导致难以追踪的依赖关系，特别是在大型项目中，理解和调试状态流可能变得更加困难

  - 副作用管理：由于 Mobx 鼓励使用可变数据和隐式依赖追踪，可能会不小心引入难以追踪的副作用，特别是在复杂交互和异步操作频繁的应用中

- 预测性和可追溯性

  相对于 Redux 明确的状态更新路径（Action -> Reducer -> Store），Mobx 的响应式和自动追踪机制可能会使状态变化的来源和流向更难以预测和追踪。这对于需要严格状态管理和事件旅行调试功能的应用可能是一个劣势

- 适用性和规模

  对于小到中型规模的项目，Mobx 的灵活性和简便性可能是明显的优势。然而，在大型项目和复杂的应用中，Redux 的严格框架和单向数据流可能提供更好的可维护性和可扩展性。团队对于代码的组织和管理有严格要求时，Redux 的模式可能更受青睐
