## 为什么 Vue3 使用了 `Proxy` 进行数据监听

### 性能提升 - 懒代理

`proxy` 允许对整个对象进行代理，而不需要事先遍历和定义其每个属性的访问器，这意味着 Vue3 可以在对象被访问时才对其进行代理，从而减少初始化时的开销。这种懒代理（lazy proxying）机制能显著提升大型对象或嵌套对象的响应式转换性能

### 更好的语言特性支持

- 更广泛的拦截能力

  与 `Object.defineProperty` 只能拦截属性的读取和设置不同，`Proxy` 能够拦截和自定义更多的操作，包括属性访问、属性赋值、枚举、函数调用等。这样 Vue3 能够更准确和全面地跟踪响应式状态的变化

- 动态属性添加

  使用 `Object.defineProperty` 时，只能对事先已知的属性进行响应式处理。而 `Proxy` 可以自动地将新添加的属性也变为响应式的，无需额外的处理。这使得开发者在使用 Vue3 时能够更灵活的处理数据

### 解决了 `Object.definePropery` 的局限性

- 数组操作

  Vue2 使用 `Object.defineProperty` 不能直接检测到数组的某些方法（例如 `push`、`pop` 等）调用导致的变化，需要通过在原生属性上进行重写来实现响应式。`Proxy` 则可以原生支持数组操作的响应式

- 嵌套对象

  在 Vue2 中，为了使嵌套对象称为响应式的，必须递归的遍历这些对象并应用 `Object.defineProperty`。而在 Vue3 中，`proxy` 可以更自然地处理嵌套对象的响应式变化
