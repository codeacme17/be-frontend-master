## HTTP/1.1、HTTP/2 带来的改变

### HTTP/1,1

HTTP/1.1 是相对于 HTTP/1.0 的升级版本，引入了一些重要的改变，主要改变如下

- 新增方法: `OPTIONS`、`PATCH`、`DELETE`、`TRACE`、`CONNECT`

- 持久链接（Keep-alive）

  HTTP/1.1 默认使用持久链接，即在单个 TCP 连接上可以发送多个请求和相应（在 HTTP/1.0 中每个请求都需要开启一个 TCP 连接），减少了建立、关闭连接的开销

- 管线化（Pipelining）

  HTTP/1.1 引入了名为 “管线化” 的机制，旨在进一步提高 HTTP 的效率，通过一个 TCP 连接上连续发送多个请求而不等待相应的响应，来减少整体的延迟。管线化机制允许客户端在收到前一个请求的响应之前，发送后续的请求。

  然而，尽管可以连续发送，服务器必须按照请求收到的顺序发送响应。这意味着，如果第一个请求的处理时间较长，后续请求的响应即使已准备好也必须等待，直到第一个请求被处理完成。同时因为兼容性的问题和并未根本的解决队头阻塞，该机制并未被广泛使用

- 分块传输编码（Chunked Transfer Encoding）

  HTTP/1.1 支持将响应分块传输，而不是等待整个响应完全生成在发送，这对于大型响应和流式数据传输非常有用，可以提前开始传输数据，提高响应速度

- HOST 头部支持

  HTTP/1.1 引入了 HOST 头部，允许一台物理服务器上托管多个域名，提高虚拟主机的支持，通过 HOST 头部可以将请求分发到不同的虚拟主机，提高服务器资源的利用率

- 缓存控制

  HTTP/1.1 引入了更多的缓存控制机制，包括 `Etag`、`If-None-Match` 头部字段，提供更细密度的缓存控制和缓存验证机制
  `Etag`/`If-Node-Match`(HTTP/1.1) 与 `Last-Modified`/`If-Modified-Since`(HTTP/1.0) 的区别

  - `Etag/If-None-Match` 有更好的精确度，可以更深层的感知资源的变化，比如文件只是编辑过但是没有更改内容，这样也会造成缓存失效

  - `Last-Modified/If-Modified-Since` 有更好的性能，因为他只是记录一个时间点，而 `Etag` 需要根据文件具体内容生成哈希值

- 断点续传（Range Requests）

  HTTP/1.1 支持断点续传，允许客户端请求资源的指定范围，实现只下载部分内容，适用于大文件下载和断点续传的场景

- 身份验证（Authentication）

  HTTP/1.1 引入了更多的身份验证机制，如基本认证、摘要认证等，提供了更安全的身份验证方式

### HTTP/2

- 多路复用（Multiplexing）

  HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双线数据流(stream)，每个数据流都以消息(message)的形式发送，消息是指少由一个 Header 帧组成的，多个帧之间可以乱序发送，根据帧中的流标识，在到达后进行组装，解决了 HTTP/1.1 对头阻塞的问题

- 二进制传输（Binary Protocol）

  HTTP/2 使用二进制格式进行数据传输，取代了 HTTP/1.1 的文本格式，这种二进制格式更加紧凑，解析效率更高，减少了数据传输的大小和网络延迟

- 头部压缩（Header Compression）

  HTTP/2 使用了 HPACK 压缩算法对头部信息进行压缩，减少了数据传输的大小。由于 HTTP/1.1 的头部信息经常重复传输，通过压缩可以大幅度减少数据量

- 服务器推送

  HTTP/2 允许服务器主动推送资源给客户端，无需客户端显式请求，当服务器发送响应时，可以在同一个 TCP 连接上推送其他相关资源，减少了客户端请求的延迟，提高了页面加载速度

- 流量控制

  HTTP/2 引入了流量控制机制，可以控制数据的传输速率，防止过载情况的发生
