## Node 与 Browser `EventLoop` 的差异

Node.js 和浏览器都实现了事件循环（Event Loop）机制，但由于他们的使用场景和设计目的不同，它们在事件循环的具体实现上存在一些差异

#### 任务处理的类型和顺序

- 浏览器

  - 浏览器的时间循环主要处理用户交互（如点击、滚动等）、脚本执行、UI 渲染、网络请求等

  - 浏览器的事件循环分为宏任务（Marci Task）和微任务（Micro Task）。每次事件循环迭代中，浏览器会首先执行宏任务队列中的一个任务，然后执行所有微任务。微任务主要包括 `Promise` 回调，`MutationObserver` 的回调等

- Node.js

  - Node.js 处理的任务更多地与 I/O 操作（如文件读写、网络请求）有关

  - Node.js 的事件循环同样分为宏任务与微任务，但与浏览器不同的是，Node.js 的事件循环还有多个阶段，如 timers、I/O callbacks、idle、prepare、poll、check、close callbacks 等。每个阶段都有自己的任务队列，事件循环会按顺序处理这些队列中的任务

#### 事件循环的实现

- 浏览器

  - 浏览器的事件循环是由 Javascript 引擎和宿主环境（浏览器）共同管理的。不同浏览器可能由细微的差别

  - 在浏览器中，事件循环与渲染引擎紧密相连，因此它会处理与渲染相关的任务

- Node.js

  - Node.js 的事件循环是基于 libuv 库实现的。libuv 是一个跨平台的异步 I/O 库，提供了统一的事件循环和异步 I/O 功能

  - Node.js 的事件循环更加关注于 I/O 处理效率，不涉及 UI 渲染

#### 微任务的处理

浏览器和 Node.js 在微任务的处理上有所不同。虽然两者都会在每个宏任务执行完后处理所有的微任务，但是在具体的实现细节上可能有差异。例如，老版本的 Node.js 在某些情况下可能不会在每个宏任务之后立即处理微任务

#### 定时器行为

在 Node.js 和浏览器中，定时器（如 `setTimeout` 和 `setInterval`）的行为可能略有不同。例如，Node.js 中定时器的精度可能受到系统负载的影响

#### 总结

尽管 Node.js 和浏览器中的事件循环都是 Javascript 运行时的核心部分，但它们在实现和处理任务的方式上有所不同，这些差异主要是由于它们服务的不同场景和需求所导致的。浏览器更关注于用户交互和 UI 渲染，而 Node.js 更侧重于高效的 I/O 处理
