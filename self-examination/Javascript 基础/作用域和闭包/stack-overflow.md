## 理解堆栈溢出和内存泄漏的原理，以及如何防止

### 原理

#### 堆栈溢出

堆栈溢出指的是程序在执行时，当调用函数时，会在栈内存中为该函数分配一定的空间，该空间由编译器分配，然后在函数执行完成后自动回收。当递归调用的次数过多，或者在函数中创建了大量的对象或数组等占用大量内存的数据结构时，可能会导致堆栈内存空间不够，从而发生堆栈溢出错误

```js
function overflow() {
  while(true) {
    overflow()
  }
}
```

#### 内存泄漏

内存泄漏指的是程序在执行时，不再使用的内存没有被及时回收，导致内存空间浪费，常见的内存泄漏有以下几种情况：

- 对象的引用计数不为零：当一个对象被创建时，会有一个引用计数器指向它，每当有一个新的对象引用该对象时，计数器加一，当对象不再被引用时，计数器减一。如果一个对象的引用计数一直不为零，即使它已经不再被使用，也无法被垃圾回收器回收，从而导致内存泄漏

- 闭包引用的变量未被释放：闭包中引用的外部变量，即使在函数执行完成后也不会被释放，直到闭包被销毁。如果闭包一直存在，这些变量就会一直存在，从而导致内存泄漏

```js
function memoLeak() {
  const a = "1"
  return function() {
    console.log(a)
  }
}
```

- 定时器未被清除：使用定时器时，如果在定时器执行之前将其清除，那么内存就不会泄漏。如果定时器一直存在，而不被清除，就会导致内存泄漏

```js
setTimeout(() => {
  console.log("timer")
}, 100)
```

### 防止

- 尽可能减少递归的次数，或者使用 **尾递归** 来避免出现堆栈溢出

- 及时清除不再使用的对象引用，使引用计数器为零，从而被垃圾回收器回收

- 在使用闭包时，尽可能避免引用过多的外部变量，或者在不需要时手动将闭包置为 `null`，以便垃圾回收器能够回收这些变量

- 在使用定时器时，要在不再需要时及时清除定时器，可以在组件卸载时清除定时器，或者在使用 `setTimeout` 时，将返回值赋予一个变量，以便在后续使用 `clearTimeout` 方法清除