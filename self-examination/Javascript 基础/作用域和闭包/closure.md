## 闭包的实现原理和作用，可以列举几个开发中闭包的实际应用

闭包是指有权访问另一个函数作用域中变量的函数，它可以访问包含它的函数中任何变量、参数以及父级作用域中的变量

### 实现原理

闭包的实现的关键是当外部函数执行完毕并返回后，其执行上下文仍然存在于内存中，因为其内部函数仍然需要访问它的作用域链，这个执行上下文的作用域链被内部函数引用，使得这些变量可以被访问

当一个函数被调用时，JS 引擎会为其创建一个执行上下文(Excution Context)，其中包括变量对象、作用域和 `this` 指针。在 JS 中，每一个函数都会有一个 `[[scope]]` 属性，用于记录函数创建时的作用域链。当函数执行时，会创建一个新的执行上下文，其中包括该函数的变量对象，以及一个新的作用域链。新的作用域链会将该函数的 `[[scope]]` 属性指向的作用域链作为其父级

当内部函数被调用时，会先在自己的作用域中查找变量，如果没有找到，就会去父级作用域链中查找，直到找到为止。如果在最外层的作用域链中都没有找到，那么就会抛出一个引用错误

所以总结来说，在正常情况下，函数的执行上下文在函数执行完成后会被消除（弹出执行栈），其函数的执行上下文也会被消除，但是由于闭包的存在，使得这个本该被消除的执行上下文还存在于内存之中，使得其他函数可以通过 `[[scope]]` 找到该函数执行上下文

```js
const creatCounter = () => {
  let count = 0
  return () => {
    count++
    console.log(count)
  }
}
const counter = creatCounter() // 执行后 `createCounter()` 函数执行上下文应该被清除
counter() // 1, 但是此时 `createCounter()` 函数执行上下文中的 `count` 变量还可以被访问到
counter() // 2
```

### 作用

利用闭包，我们可以创建私有变量和私有函数，可以将函数作为参数传递给另一个函数，可以实现柯里化、高阶函数等功能

### 实际开发

- 封装变量：通过闭包封装变量，可以实现私有成员的访问和修改，避免全局变量的污染

- 延迟函数执行：通过返回一个函数来延迟函数的执行，可以实现一些高级的应用，比如函数记忆和防抖节流等

- 封装回调函数：将回调函数作为参数传递给其他函数时，可以使用闭包来实现数据共享和上下文切换

- 模块化开发：通过闭包封装模块的内部实现细节，将接口暴露给外部使用，可以有效地实现模块化开发

### 缺点

- 内存泄漏：因为闭包中引用了外部函数的变量，导致函数的执行环境无法被释放，占用内存过多可能会导致内存泄漏

- 性能问题：闭包中的作用域链和变量对象不能被回收，执行效率比普通函数略低

- 容易造成变量污染：闭包中的变量可以在外部被修改，容易造成不可预料的结果

- 可能造成代码维护困难：过度使用闭包会是代码变得复杂，难以维护